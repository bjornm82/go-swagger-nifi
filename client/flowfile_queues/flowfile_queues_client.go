// Code generated by go-swagger; DO NOT EDIT.

package flowfile_queues

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"github.com/go-openapi/runtime"

	strfmt "github.com/go-openapi/strfmt"
)

// New creates a new flowfile queues API client.
func New(transport runtime.ClientTransport, formats strfmt.Registry) *Client {
	return &Client{transport: transport, formats: formats}
}

/*
Client for flowfile queues API
*/
type Client struct {
	transport runtime.ClientTransport
	formats   strfmt.Registry
}

/*
CreateDropRequest creates a request to drop the contents of the queue in this connection
*/
func (a *Client) CreateDropRequest(params *CreateDropRequestParams, authInfo runtime.ClientAuthInfoWriter) (*CreateDropRequestOK, *CreateDropRequestAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateDropRequestParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "createDropRequest",
		Method:             "POST",
		PathPattern:        "/flowfile-queues/{id}/drop-requests",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &CreateDropRequestReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *CreateDropRequestOK:
		return value, nil, nil
	case *CreateDropRequestAccepted:
		return nil, value, nil
	}
	return nil, nil, nil

}

/*
CreateFlowFileListing lists the contents of the queue in this connection
*/
func (a *Client) CreateFlowFileListing(params *CreateFlowFileListingParams, authInfo runtime.ClientAuthInfoWriter) (*CreateFlowFileListingOK, *CreateFlowFileListingAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateFlowFileListingParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "createFlowFileListing",
		Method:             "POST",
		PathPattern:        "/flowfile-queues/{id}/listing-requests",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &CreateFlowFileListingReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *CreateFlowFileListingOK:
		return value, nil, nil
	case *CreateFlowFileListingAccepted:
		return nil, value, nil
	}
	return nil, nil, nil

}

/*
DeleteListingRequest cancels and or removes a request to list the contents of this connection
*/
func (a *Client) DeleteListingRequest(params *DeleteListingRequestParams, authInfo runtime.ClientAuthInfoWriter) (*DeleteListingRequestOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteListingRequestParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "deleteListingRequest",
		Method:             "DELETE",
		PathPattern:        "/flowfile-queues/{id}/listing-requests/{listing-request-id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DeleteListingRequestReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*DeleteListingRequestOK), nil

}

/*
DownloadFlowFileContent gets the content for a flow file in a connection
*/
func (a *Client) DownloadFlowFileContent(params *DownloadFlowFileContentParams, authInfo runtime.ClientAuthInfoWriter) (*DownloadFlowFileContentOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDownloadFlowFileContentParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "downloadFlowFileContent",
		Method:             "GET",
		PathPattern:        "/flowfile-queues/{id}/flowfiles/{flowfile-uuid}/content",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DownloadFlowFileContentReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*DownloadFlowFileContentOK), nil

}

/*
FlowfileQueuesRemoveDropRequest cancels and or removes a request to drop the contents of this connection
*/
func (a *Client) FlowfileQueuesRemoveDropRequest(params *FlowfileQueuesRemoveDropRequestParams, authInfo runtime.ClientAuthInfoWriter) (*FlowfileQueuesRemoveDropRequestOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFlowfileQueuesRemoveDropRequestParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "flowfileQueuesRemoveDropRequest",
		Method:             "DELETE",
		PathPattern:        "/flowfile-queues/{id}/drop-requests/{drop-request-id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &FlowfileQueuesRemoveDropRequestReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*FlowfileQueuesRemoveDropRequestOK), nil

}

/*
GetDropRequest gets the current status of a drop request for the specified connection
*/
func (a *Client) GetDropRequest(params *GetDropRequestParams, authInfo runtime.ClientAuthInfoWriter) (*GetDropRequestOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetDropRequestParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getDropRequest",
		Method:             "GET",
		PathPattern:        "/flowfile-queues/{id}/drop-requests/{drop-request-id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetDropRequestReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetDropRequestOK), nil

}

/*
GetFlowFile gets a flow file from a connection
*/
func (a *Client) GetFlowFile(params *GetFlowFileParams, authInfo runtime.ClientAuthInfoWriter) (*GetFlowFileOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetFlowFileParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getFlowFile",
		Method:             "GET",
		PathPattern:        "/flowfile-queues/{id}/flowfiles/{flowfile-uuid}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetFlowFileReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetFlowFileOK), nil

}

/*
GetListingRequest gets the current status of a listing request for the specified connection
*/
func (a *Client) GetListingRequest(params *GetListingRequestParams, authInfo runtime.ClientAuthInfoWriter) (*GetListingRequestOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetListingRequestParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getListingRequest",
		Method:             "GET",
		PathPattern:        "/flowfile-queues/{id}/listing-requests/{listing-request-id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetListingRequestReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetListingRequestOK), nil

}

// SetTransport changes the transport on the client
func (a *Client) SetTransport(transport runtime.ClientTransport) {
	a.transport = transport
}

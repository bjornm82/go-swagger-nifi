// Code generated by go-swagger; DO NOT EDIT.

package access

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"fmt"

	"github.com/go-openapi/runtime"
	"github.com/go-openapi/strfmt"
)

// New creates a new access API client.
func New(transport runtime.ClientTransport, formats strfmt.Registry) ClientService {
	return &Client{transport: transport, formats: formats}
}

/*
Client for access API
*/
type Client struct {
	transport runtime.ClientTransport
	formats   strfmt.Registry
}

// ClientService is the interface for Client methods
type ClientService interface {
	CreateAccessToken(params *CreateAccessTokenParams) (*CreateAccessTokenCreated, error)

	CreateAccessTokenFromTicket(params *CreateAccessTokenFromTicketParams) (*CreateAccessTokenFromTicketCreated, error)

	CreateDownloadToken(params *CreateDownloadTokenParams) (*CreateDownloadTokenCreated, error)

	CreateUIExtensionToken(params *CreateUIExtensionTokenParams) (*CreateUIExtensionTokenCreated, error)

	GetAccessStatus(params *GetAccessStatusParams) (*GetAccessStatusOK, error)

	GetLoginConfigAccess(params *GetLoginConfigAccessParams) (*GetLoginConfigAccessOK, error)

	KnoxCallback(params *KnoxCallbackParams) error

	KnoxLogout(params *KnoxLogoutParams) error

	KnoxRequest(params *KnoxRequestParams) error

	LogOut(params *LogOutParams) (*LogOutOK, error)

	LogOutCompleteAccess(params *LogOutCompleteAccessParams) (*LogOutCompleteAccessOK, error)

	SetTransport(transport runtime.ClientTransport)
}

/*
  CreateAccessToken creates a token for accessing the r e s t API via username password

  The token returned is formatted as a JSON Web Token (JWT). The token is base64 encoded and comprised of three parts. The header, the body, and the signature. The expiration of the token is a contained within the body. It is stored in the browser as a cookie, but also returned inthe response body to be stored/used by third party client scripts.
*/
func (a *Client) CreateAccessToken(params *CreateAccessTokenParams) (*CreateAccessTokenCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateAccessTokenParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "createAccessToken",
		Method:             "POST",
		PathPattern:        "/access/token",
		ProducesMediaTypes: []string{"text/plain"},
		ConsumesMediaTypes: []string{"application/x-www-form-urlencoded"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &CreateAccessTokenReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CreateAccessTokenCreated)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for createAccessToken: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  CreateAccessTokenFromTicket creates a token for accessing the r e s t API via kerberos ticket exchange s p n e g o negotiation

  The token returned is formatted as a JSON Web Token (JWT). The token is base64 encoded and comprised of three parts. The header, the body, and the signature. The expiration of the token is a contained within the body. The token can be used in the Authorization header in the format 'Authorization: Bearer <token>'. It is also stored in the browser as a cookie.
*/
func (a *Client) CreateAccessTokenFromTicket(params *CreateAccessTokenFromTicketParams) (*CreateAccessTokenFromTicketCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateAccessTokenFromTicketParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "createAccessTokenFromTicket",
		Method:             "POST",
		PathPattern:        "/access/kerberos",
		ProducesMediaTypes: []string{"text/plain"},
		ConsumesMediaTypes: []string{"text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &CreateAccessTokenFromTicketReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CreateAccessTokenFromTicketCreated)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for createAccessTokenFromTicket: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  CreateDownloadToken creates a single use access token for downloading flow file content

  The token returned is a base64 encoded string. It is valid for a single request up to five minutes from being issued. It is used as a query parameter name 'access_token'.
*/
func (a *Client) CreateDownloadToken(params *CreateDownloadTokenParams) (*CreateDownloadTokenCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateDownloadTokenParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "createDownloadToken",
		Method:             "POST",
		PathPattern:        "/access/download-token",
		ProducesMediaTypes: []string{"text/plain"},
		ConsumesMediaTypes: []string{"application/x-www-form-urlencoded"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &CreateDownloadTokenReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CreateDownloadTokenCreated)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for createDownloadToken: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  CreateUIExtensionToken creates a single use access token for accessing a ni fi UI extension

  The token returned is a base64 encoded string. It is valid for a single request up to five minutes from being issued. It is used as a query parameter name 'access_token'.
*/
func (a *Client) CreateUIExtensionToken(params *CreateUIExtensionTokenParams) (*CreateUIExtensionTokenCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateUIExtensionTokenParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "createUiExtensionToken",
		Method:             "POST",
		PathPattern:        "/access/ui-extension-token",
		ProducesMediaTypes: []string{"text/plain"},
		ConsumesMediaTypes: []string{"application/x-www-form-urlencoded"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &CreateUIExtensionTokenReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CreateUIExtensionTokenCreated)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for createUiExtensionToken: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  GetAccessStatus gets the status the client s access

  Note: This endpoint is subject to change as NiFi and it's REST API evolve.
*/
func (a *Client) GetAccessStatus(params *GetAccessStatusParams) (*GetAccessStatusOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetAccessStatusParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getAccessStatus",
		Method:             "GET",
		PathPattern:        "/access",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetAccessStatusReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetAccessStatusOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for getAccessStatus: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  GetLoginConfigAccess retrieves the access configuration for this ni fi
*/
func (a *Client) GetLoginConfigAccess(params *GetLoginConfigAccessParams) (*GetLoginConfigAccessOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetLoginConfigAccessParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getLoginConfigAccess",
		Method:             "GET",
		PathPattern:        "/access/config",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetLoginConfigAccessReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetLoginConfigAccessOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for getLoginConfigAccess: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  KnoxCallback redirects callback URI for processing the result of the apache knox login sequence

  Note: This endpoint is subject to change as NiFi and it's REST API evolve.
*/
func (a *Client) KnoxCallback(params *KnoxCallbackParams) error {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewKnoxCallbackParams()
	}

	_, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "knoxCallback",
		Method:             "GET",
		PathPattern:        "/access/knox/callback",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &KnoxCallbackReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return err
	}
	return nil
}

/*
  KnoxLogout performs a logout in the apache knox

  Note: This endpoint is subject to change as NiFi and it's REST API evolve.
*/
func (a *Client) KnoxLogout(params *KnoxLogoutParams) error {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewKnoxLogoutParams()
	}

	_, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "knoxLogout",
		Method:             "GET",
		PathPattern:        "/access/knox/logout",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &KnoxLogoutReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return err
	}
	return nil
}

/*
  KnoxRequest initiates a request to authenticate through apache knox

  Note: This endpoint is subject to change as NiFi and it's REST API evolve.
*/
func (a *Client) KnoxRequest(params *KnoxRequestParams) error {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewKnoxRequestParams()
	}

	_, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "knoxRequest",
		Method:             "GET",
		PathPattern:        "/access/knox/request",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &KnoxRequestReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return err
	}
	return nil
}

/*
  LogOut performs a logout for other providers that have been issued a j w t

  Note: This endpoint is subject to change as NiFi and it's REST API evolve.
*/
func (a *Client) LogOut(params *LogOutParams) (*LogOutOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewLogOutParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "logOut",
		Method:             "DELETE",
		PathPattern:        "/access/logout",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &LogOutReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*LogOutOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for logOut: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  LogOutCompleteAccess completes the logout sequence by removing the cached logout request and cookie if they existed and redirects to nifi login

  Note: This endpoint is subject to change as NiFi and it's REST API evolve.
*/
func (a *Client) LogOutCompleteAccess(params *LogOutCompleteAccessParams) (*LogOutCompleteAccessOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewLogOutCompleteAccessParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "logOutCompleteAccess",
		Method:             "GET",
		PathPattern:        "/access/logout/complete",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &LogOutCompleteAccessReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*LogOutCompleteAccessOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for logOutCompleteAccess: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

// SetTransport changes the transport on the client
func (a *Client) SetTransport(transport runtime.ClientTransport) {
	a.transport = transport
}

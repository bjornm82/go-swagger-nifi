// Code generated by go-swagger; DO NOT EDIT.

package access

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"github.com/go-openapi/runtime"

	strfmt "github.com/go-openapi/strfmt"
)

// New creates a new access API client.
func New(transport runtime.ClientTransport, formats strfmt.Registry) *Client {
	return &Client{transport: transport, formats: formats}
}

/*
Client for access API
*/
type Client struct {
	transport runtime.ClientTransport
	formats   strfmt.Registry
}

/*
CreateAccessToken creates a token for accessing the r e s t API via username password

The token returned is formatted as a JSON Web Token (JWT). The token is base64 encoded and comprised of three parts. The header, the body, and the signature. The expiration of the token is a contained within the body. The token can be used in the Authorization header in the format 'Authorization: Bearer <token>'.
*/
func (a *Client) CreateAccessToken(params *CreateAccessTokenParams) (*CreateAccessTokenOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateAccessTokenParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "createAccessToken",
		Method:             "POST",
		PathPattern:        "/access/token",
		ProducesMediaTypes: []string{"text/plain"},
		ConsumesMediaTypes: []string{"application/x-www-form-urlencoded"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &CreateAccessTokenReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*CreateAccessTokenOK), nil

}

/*
CreateAccessTokenFromTicket creates a token for accessing the r e s t API via kerberos ticket exchange s p n e g o negotiation

The token returned is formatted as a JSON Web Token (JWT). The token is base64 encoded and comprised of three parts. The header, the body, and the signature. The expiration of the token is a contained within the body. The token can be used in the Authorization header in the format 'Authorization: Bearer <token>'.
*/
func (a *Client) CreateAccessTokenFromTicket(params *CreateAccessTokenFromTicketParams) (*CreateAccessTokenFromTicketOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateAccessTokenFromTicketParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "createAccessTokenFromTicket",
		Method:             "POST",
		PathPattern:        "/access/kerberos",
		ProducesMediaTypes: []string{"text/plain"},
		ConsumesMediaTypes: []string{"text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &CreateAccessTokenFromTicketReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*CreateAccessTokenFromTicketOK), nil

}

/*
CreateDownloadToken creates a single use access token for downloading flow file content

The token returned is a base64 encoded string. It is valid for a single request up to five minutes from being issued. It is used as a query parameter name 'access_token'.
*/
func (a *Client) CreateDownloadToken(params *CreateDownloadTokenParams) (*CreateDownloadTokenOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateDownloadTokenParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "createDownloadToken",
		Method:             "POST",
		PathPattern:        "/access/download-token",
		ProducesMediaTypes: []string{"text/plain"},
		ConsumesMediaTypes: []string{"application/x-www-form-urlencoded"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &CreateDownloadTokenReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*CreateDownloadTokenOK), nil

}

/*
CreateUIExtensionToken creates a single use access token for accessing a ni fi UI extension

The token returned is a base64 encoded string. It is valid for a single request up to five minutes from being issued. It is used as a query parameter name 'access_token'.
*/
func (a *Client) CreateUIExtensionToken(params *CreateUIExtensionTokenParams) (*CreateUIExtensionTokenOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateUIExtensionTokenParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "createUiExtensionToken",
		Method:             "POST",
		PathPattern:        "/access/ui-extension-token",
		ProducesMediaTypes: []string{"text/plain"},
		ConsumesMediaTypes: []string{"application/x-www-form-urlencoded"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &CreateUIExtensionTokenReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*CreateUIExtensionTokenOK), nil

}

/*
GetAccessStatus gets the status the client s access

Note: This endpoint is subject to change as NiFi and it's REST API evolve.
*/
func (a *Client) GetAccessStatus(params *GetAccessStatusParams) (*GetAccessStatusOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetAccessStatusParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getAccessStatus",
		Method:             "GET",
		PathPattern:        "/access",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetAccessStatusReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetAccessStatusOK), nil

}

/*
GetLoginConfig retrieves the access configuration for this ni fi
*/
func (a *Client) GetLoginConfig(params *GetLoginConfigParams) (*GetLoginConfigOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetLoginConfigParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getLoginConfig",
		Method:             "GET",
		PathPattern:        "/access/config",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetLoginConfigReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetLoginConfigOK), nil

}

/*
KnoxCallback redirects callback URI for processing the result of the apache knox login sequence

Note: This endpoint is subject to change as NiFi and it's REST API evolve.
*/
func (a *Client) KnoxCallback(params *KnoxCallbackParams) error {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewKnoxCallbackParams()
	}

	_, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "knoxCallback",
		Method:             "GET",
		PathPattern:        "/access/knox/callback",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &KnoxCallbackReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return err
	}
	return nil

}

/*
KnoxLogout performs a logout in the apache knox

Note: This endpoint is subject to change as NiFi and it's REST API evolve.
*/
func (a *Client) KnoxLogout(params *KnoxLogoutParams) error {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewKnoxLogoutParams()
	}

	_, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "knoxLogout",
		Method:             "GET",
		PathPattern:        "/access/knox/logout",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &KnoxLogoutReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return err
	}
	return nil

}

/*
KnoxRequest initiates a request to authenticate through apache knox

Note: This endpoint is subject to change as NiFi and it's REST API evolve.
*/
func (a *Client) KnoxRequest(params *KnoxRequestParams) error {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewKnoxRequestParams()
	}

	_, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "knoxRequest",
		Method:             "GET",
		PathPattern:        "/access/knox/request",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &KnoxRequestReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return err
	}
	return nil

}

/*
LogOut performs a logout for other providers that have been issued a j w t

Note: This endpoint is subject to change as NiFi and it's REST API evolve.
*/
func (a *Client) LogOut(params *LogOutParams) (*LogOutOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewLogOutParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "logOut",
		Method:             "DELETE",
		PathPattern:        "/access/logout",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &LogOutReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*LogOutOK), nil

}

/*
LogOutComplete completes the logout sequence by removing the cached logout request and cookie if they existed and redirects to nifi login

Note: This endpoint is subject to change as NiFi and it's REST API evolve.
*/
func (a *Client) LogOutComplete(params *LogOutCompleteParams) (*LogOutCompleteOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewLogOutCompleteParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "logOutComplete",
		Method:             "GET",
		PathPattern:        "/access/logout/complete",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &LogOutCompleteReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*LogOutCompleteOK), nil

}

/*
OidcCallback redirects callback URI for processing the result of the open Id connect login sequence

Note: This endpoint is subject to change as NiFi and it's REST API evolve.
*/
func (a *Client) OidcCallback(params *OidcCallbackParams) error {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewOidcCallbackParams()
	}

	_, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "oidcCallback",
		Method:             "GET",
		PathPattern:        "/access/oidc/callback",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &OidcCallbackReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return err
	}
	return nil

}

/*
OidcExchange retrieves a j w t following a successful login sequence using the configured open Id connect provider

Note: This endpoint is subject to change as NiFi and it's REST API evolve.
*/
func (a *Client) OidcExchange(params *OidcExchangeParams) (*OidcExchangeOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewOidcExchangeParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "oidcExchange",
		Method:             "POST",
		PathPattern:        "/access/oidc/exchange",
		ProducesMediaTypes: []string{"text/plain"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &OidcExchangeReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*OidcExchangeOK), nil

}

/*
OidcLogout performs a logout in the open Id provider

Note: This endpoint is subject to change as NiFi and it's REST API evolve.
*/
func (a *Client) OidcLogout(params *OidcLogoutParams) error {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewOidcLogoutParams()
	}

	_, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "oidcLogout",
		Method:             "GET",
		PathPattern:        "/access/oidc/logout",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &OidcLogoutReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return err
	}
	return nil

}

/*
OidcLogoutCallback redirects callback URI for processing the result of the open Id connect logout sequence

Note: This endpoint is subject to change as NiFi and it's REST API evolve.
*/
func (a *Client) OidcLogoutCallback(params *OidcLogoutCallbackParams) error {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewOidcLogoutCallbackParams()
	}

	_, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "oidcLogoutCallback",
		Method:             "GET",
		PathPattern:        "/access/oidc/logoutCallback",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &OidcLogoutCallbackReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return err
	}
	return nil

}

/*
OidcRequest initiates a request to authenticate through the configured open Id connect provider

Note: This endpoint is subject to change as NiFi and it's REST API evolve.
*/
func (a *Client) OidcRequest(params *OidcRequestParams) error {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewOidcRequestParams()
	}

	_, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "oidcRequest",
		Method:             "GET",
		PathPattern:        "/access/oidc/request",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &OidcRequestReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return err
	}
	return nil

}

/*
SamlLocalLogout locals logout when s a m l is enabled does not communicate with the ID p

Note: This endpoint is subject to change as NiFi and it's REST API evolve.
*/
func (a *Client) SamlLocalLogout(params *SamlLocalLogoutParams) error {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewSamlLocalLogoutParams()
	}

	_, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "samlLocalLogout",
		Method:             "GET",
		PathPattern:        "/access/saml/local-logout",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &SamlLocalLogoutReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return err
	}
	return nil

}

/*
SamlLoginExchange retrieves a j w t following a successful login sequence using the configured s a m l identity provider

Note: This endpoint is subject to change as NiFi and it's REST API evolve.
*/
func (a *Client) SamlLoginExchange(params *SamlLoginExchangeParams) (*SamlLoginExchangeOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewSamlLoginExchangeParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "samlLoginExchange",
		Method:             "POST",
		PathPattern:        "/access/saml/login/exchange",
		ProducesMediaTypes: []string{"text/plain"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &SamlLoginExchangeReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*SamlLoginExchangeOK), nil

}

/*
SamlLoginHTTPPostConsumer processes the s s o response from the s a m l identity provider for HTTP p o s t binding

Note: This endpoint is subject to change as NiFi and it's REST API evolve.
*/
func (a *Client) SamlLoginHTTPPostConsumer(params *SamlLoginHTTPPostConsumerParams) error {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewSamlLoginHTTPPostConsumerParams()
	}

	_, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "samlLoginHttpPostConsumer",
		Method:             "POST",
		PathPattern:        "/access/saml/login/consumer",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/x-www-form-urlencoded"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &SamlLoginHTTPPostConsumerReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return err
	}
	return nil

}

/*
SamlLoginHTTPRedirectConsumer processes the s s o response from the s a m l identity provider for HTTP r e d i r e c t binding

Note: This endpoint is subject to change as NiFi and it's REST API evolve.
*/
func (a *Client) SamlLoginHTTPRedirectConsumer(params *SamlLoginHTTPRedirectConsumerParams) error {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewSamlLoginHTTPRedirectConsumerParams()
	}

	_, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "samlLoginHttpRedirectConsumer",
		Method:             "GET",
		PathPattern:        "/access/saml/login/consumer",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &SamlLoginHTTPRedirectConsumerReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return err
	}
	return nil

}

/*
SamlLoginRequest initiates an s s o request to the configured s a m l identity provider

Note: This endpoint is subject to change as NiFi and it's REST API evolve.
*/
func (a *Client) SamlLoginRequest(params *SamlLoginRequestParams) error {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewSamlLoginRequestParams()
	}

	_, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "samlLoginRequest",
		Method:             "GET",
		PathPattern:        "/access/saml/login/request",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &SamlLoginRequestReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return err
	}
	return nil

}

/*
SamlMetadata retrieves the service provider metadata

Note: This endpoint is subject to change as NiFi and it's REST API evolve.
*/
func (a *Client) SamlMetadata(params *SamlMetadataParams) error {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewSamlMetadataParams()
	}

	_, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "samlMetadata",
		Method:             "GET",
		PathPattern:        "/access/saml/metadata",
		ProducesMediaTypes: []string{"application/samlmetadata+xml"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &SamlMetadataReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return err
	}
	return nil

}

/*
SamlSingleLogoutHTTPPostConsumer processes a single logout message from the configured s a m l identity provider using the HTTP p o s t binding

Note: This endpoint is subject to change as NiFi and it's REST API evolve.
*/
func (a *Client) SamlSingleLogoutHTTPPostConsumer(params *SamlSingleLogoutHTTPPostConsumerParams) error {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewSamlSingleLogoutHTTPPostConsumerParams()
	}

	_, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "samlSingleLogoutHttpPostConsumer",
		Method:             "POST",
		PathPattern:        "/access/saml/single-logout/consumer",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &SamlSingleLogoutHTTPPostConsumerReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return err
	}
	return nil

}

/*
SamlSingleLogoutHTTPRedirectConsumer processes a single logout message from the configured s a m l identity provider using the HTTP r e d i r e c t binding

Note: This endpoint is subject to change as NiFi and it's REST API evolve.
*/
func (a *Client) SamlSingleLogoutHTTPRedirectConsumer(params *SamlSingleLogoutHTTPRedirectConsumerParams) error {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewSamlSingleLogoutHTTPRedirectConsumerParams()
	}

	_, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "samlSingleLogoutHttpRedirectConsumer",
		Method:             "GET",
		PathPattern:        "/access/saml/single-logout/consumer",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &SamlSingleLogoutHTTPRedirectConsumerReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return err
	}
	return nil

}

/*
SamlSingleLogoutRequest initiates a logout request using the single logout service of the configured s a m l identity provider

Note: This endpoint is subject to change as NiFi and it's REST API evolve.
*/
func (a *Client) SamlSingleLogoutRequest(params *SamlSingleLogoutRequestParams) error {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewSamlSingleLogoutRequestParams()
	}

	_, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "samlSingleLogoutRequest",
		Method:             "GET",
		PathPattern:        "/access/saml/single-logout/request",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &SamlSingleLogoutRequestReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return err
	}
	return nil

}

// SetTransport changes the transport on the client
func (a *Client) SetTransport(transport runtime.ClientTransport) {
	a.transport = transport
}
